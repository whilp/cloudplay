#!/usr/bin/env python

import codecs
import json
import logging
import sys

import requests

from collections import namedtuple
from functools import partial
from urllib import urlencode
from urlparse import urljoin

from lxml.builder import E
from lxml import etree as xml

log = logging.getLogger(__name__)

def main():
    log.level = logging.DEBUG
    log.addHandler(logging.StreamHandler())

    client = SoundCloud()

    user = sys.argv[1]
    tracks = client.users(user).tracks
    playlist = Playlist(tracks=tracks)

    with opener(user + ".xspf", 'w') as f:
        f.write(playlist.xspf)

Track = namedtuple('Track', 'location creator title')

class SoundCloud(object):
    url = 'https://api.soundcloud.com/'
    client_id = 'bed25dba5cb38c07ca8d5bb9d92eb0a8'
    limit = 200
    format = 'json'

    def users(self, user):
        return SoundCloudUser(user=user, client=self)

    def list(self, collection, **query):
        url = urljoin(self.url, collection)
        params = dict(
            client_id=self.client_id,
            format=self.format,
            limit=self.limit,
            offset = 0,
            )
        params.update(query)
        
        url = urljoin(self.url, collection)

        while True:
            response = self.get(url + '?' + urlencode(params))
            items = json.loads(response.text)
            if not items:
                return

            params['offset'] += len(items)
            log.debug('received %d items', len(items))
            for item in items:
                yield item

    def get(self, url, **kwargs):
        log.debug('GET %s', url)
        return requests.get(url, **kwargs)

class SoundCloudUser(object):

    def __init__(self, user=None, client=None, **kwargs):
        self.user = user
        self.client = client

    @property
    def tracks(self):
        resource = "/users/{user}/tracks".format(user=self.user)
        for track in self.client.list(resource):
            if not track["streamable"]:
                continue
            yield Track(
                title=track["title"],
                creator=track["user"]["username"],
                location=track["stream_url"])

class Playlist(object):

    def __init__(self, tracks=None, **kwargs):
        self.tracks = tracks
    
    @property
    def xspf(self):
        return xml.tostring(E.playlist(
            E.trackList(*
                [E.track(
                    E.location(track.location),
                    E.creator(track.creator),
                    E.title(track.title))
                for track in self.tracks])))

opener = partial(codecs.open, encoding="utf-8")

main()
