#!/usr/bin/env python

import codecs
import json
import logging
import sys

from collections import namedtuple
from functools import partial
from optparse import OptionParser, make_option as Opt
from urllib import urlencode
from urlparse import urljoin, urlparse

import requests

from lxml.builder import E
from lxml import etree as xml

log = logging.getLogger(__name__)

def main():
    optparser = OptionParser(usage=__doc__, option_list=options)
    (opts, args) = optparser.parse_args()

    verbose = int(opts.verbose)
    if verbose > 0:
        log.level = max(1, logging.WARNING - (10 * verbose))
        log.addHandler(logging.StreamHandler())

    source = sys.argv[1]
    domain = urlparse(source).netloc

    try:
        service = services[domain]
    except KeyError:
        sys.stderr.write("unsupported service: %s\n" % domain)
        return 1

    user = source.split("/")[-1]
    
    client = service()

    tracks = client.users(user).tracks
    playlist = Playlist(tracks=tracks)

    with opener(user + ".xspf", 'w') as f:
        f.write(playlist.xspf)

options = [
    Opt("-v", "--verbose", default=0, help="logging verbosity"),
]

Track = namedtuple('Track', 'location creator title info')

class SoundCloud(object):
    url = 'https://api.soundcloud.com/'
    id = 'bed25dba5cb38c07ca8d5bb9d92eb0a8'
    limit = 200
    format = 'json'

    def users(self, user):
        return SoundCloudUser(user=user, client=self)

    def list(self, collection, **query):
        url = urljoin(self.url, collection)
        params = dict(
            client_id=self.id,
            format=self.format,
            limit=self.limit,
            offset = 0,
            )
        params.update(query)
        
        url = urljoin(self.url, collection)

        while True:
            response = self.get(url + '?' + urlencode(params))
            items = json.loads(response.text)
            if not items:
                return

            params['offset'] += len(items)
            log.debug('received %d items', len(items))
            for item in items:
                yield item

    def get(self, url, **kwargs):
        log.debug('GET %s', url)
        return requests.get(url, **kwargs)

class SoundCloudUser(object):

    def __init__(self, user=None, client=None, **kwargs):
        self.user = user
        self.client = client

    @property
    def tracks(self):
        resource = "/users/{user}/tracks".format(user=self.user)
        for track in self.client.list(resource):
            if not track["streamable"]:
                continue
            url = track["stream_url"] + '?' + urlencode(dict(client_id=self.client.id))
            url = url.replace("https://", "http://")
            yield Track(
                title=unicode(track["title"]),
                creator=unicode(track["user"]["username"]),
                location=unicode(url),
                info=unicode(track["permalink_url"],
                ))

class OfficialFM(object):
    pass

services = {
    "soundcloud.com": SoundCloud,
    "official.fm": OfficialFM,
}

class Playlist(object):

    def __init__(self, tracks=None, **kwargs):
        self.tracks = tracks
    
    @property
    def xspf(self):
        return xml.tostring(E.playlist(
            E.trackList(*[
                E.track(
                    E.location(track.location),
                    E.title(track.title),
                    E.creator(track.creator),
                    E.info(track.info),
                ) for track in self.tracks])),
        pretty_print=True)

opener = partial(codecs.open, encoding="utf-8")

main()
